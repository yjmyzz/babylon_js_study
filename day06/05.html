<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Collision Detect</title>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 70%;
            height: 70%;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            margin: auto;
            touch-action: none;
        }

        #canvasZone {
            width: 100%;
            height: 100%;
        }
    </style>

    <script src="../js/babylon.js"></script>
    <script src="../js/babylonjs.loaders.min.js"></script>
    <!-- <script src="../js/earcut.min.js"></script>
    <script src="../js/pep.js"></script> -->
</head>

<body>
    <canvas id="renderCanvas" touch-action="none"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);


        const createScene = () => {
            const scene = new BABYLON.Scene(engine);

            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0));
            camera.attachControl(canvas, true);
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));


            BABYLON.SceneLoader.ImportMeshAsync("", "../assets/glb/", "car.babylon").then((result) => {
                var car1 = scene.getMeshByName("car");
                car1.position = new BABYLON.Vector3(-6, 0, 0);
                car1.scaling = new BABYLON.Vector3(4, 4, 4);

                const wheelRB = scene.getMeshByName("wheelRB");
                const wheelRF = scene.getMeshByName("wheelRF");
                const wheelLB = scene.getMeshByName("wheelLB");
                const wheelLF = scene.getMeshByName("wheelLF");
                let wheels = [wheelRB, wheelRF, wheelLB, wheelLF];
                let wheelAnimatables = [];
                for (let i = 0; i < wheels.length; i++) {
                    wheelAnimatables.push(scene.beginAnimation(wheels[i], 0, 30, true));
                }

                const animCar = new BABYLON.Animation("carAnimation", "position.x", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                const carKeys = [];
                carKeys.push({
                    frame: 0,
                    value: -6
                });
                carKeys.push({
                    frame: 120,
                    value: 6
                });

                animCar.setKeys(carKeys);

                car1.animations = [];
                car1.animations.push(animCar);

                let carAnimable = scene.beginAnimation(car1, 0, 120, true);

                //复制出第2辆车，挡在路上
                var car2 = car1.clone("car2");
                car2.position = new BABYLON.Vector3(2, 0, 0.4);
                car2.rotation.y = Math.PI;
                car2.scaling = car1.scaling;

                //注：第2辆车刚复制出来的瞬间，位置与第1辆车就重合了，会导致一出场就碰了，因此要借助ready把首次碰排除掉
                let ready = false;

                //控制下一帧的行为
                scene.onBeforeRenderObservable.add(() => {
                    //发生碰撞
                    if (car1.intersectsMesh(car2)) {
                        if (!ready) {
                            ready = true;
                            return;
                        }

                        if (ready) {
                            //停止动画
                            carAnimable.stop();
                            //模拟第1辆车，被撞飞
                            car1.rotate(BABYLON.Axis.Y, Math.PI * 0.4, BABYLON.Space.LOCAL);
                            car1.position.x -= 0.2;
                            car1.position.y += 0.5;
                            return;

                        }

                    }

                });
            });

            //showAxis(4, scene);
            return scene;
        }



        /***********Create and Draw Axes**************************************/
        const showAxis = (size, scene) => {
            const makeTextPlane = (text, color, size) => {
                const dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
                dynamicTexture.hasAlpha = true;
                dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color, "transparent", true);
                const plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
                plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
                plane.material.backFaceCulling = false;
                plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
                plane.material.diffuseTexture = dynamicTexture;
                return plane;
            };

            const axisX = BABYLON.Mesh.CreateLines("axisX", [
                new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
                new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
            ]);
            axisX.color = new BABYLON.Color3(1, 0, 1);
            const xChar = makeTextPlane("X", "yellow", size / 7);
            xChar.position = new BABYLON.Vector3(0.9 * size, 0.07 * size, 0);

            const axisY = BABYLON.Mesh.CreateLines("axisY", [
                new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),
                new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)
            ]);
            axisY.color = new BABYLON.Color3(0, 1, 0);
            const yChar = makeTextPlane("Y", "white", size / 7);
            yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);

            const axisZ = BABYLON.Mesh.CreateLines("axisZ", [
                new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),
                new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)
            ]);
            axisZ.color = new BABYLON.Color3(0.5, 1, 1);
            const zChar = makeTextPlane("Z", "white", size / 7);
            zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
        };


        const scene = createScene();

        engine.runRenderLoop(function () {
            scene.render();
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });


    </script>
</body>

</html>